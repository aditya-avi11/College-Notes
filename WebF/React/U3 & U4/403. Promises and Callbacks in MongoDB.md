
When working with MongoDB in **Node.js**, you often perform database operations that take time to complete. To handle these asynchronous operations, MongoDB provides **callbacks** and **promises**.

---

## **1. Callbacks in MongoDB**

A **callback function** is a function passed as an argument to another function, which is then executed once the operation is complete.

### **Example: Using Callbacks in MongoDB**

```js
const { MongoClient } = require("mongodb");

const uri = "mongodb://localhost:27017";
const client = new MongoClient(uri);

client.connect((err) => {
  if (err) {
    console.error("Connection failed:", err);
    return;
  }
  console.log("Connected to MongoDB");

  const db = client.db("mydatabase");
  const collection = db.collection("users");

  // Insert a document using a callback
  collection.insertOne({ name: "Alice", age: 25 }, (err, result) => {
    if (err) {
      console.error("Insertion failed:", err);
      return;
    }
    console.log("Document inserted:", result.insertedId);

    // Close the connection
    client.close();
  });
});
```

### **Key Points About Callbacks:**

âœ” **Functions execute only when the database operation completes.**  
âœ” **Nested callbacks can lead to "Callback Hell" (deep nesting).**  
âœ” **Difficult to handle errors efficiently in deeply nested callbacks.**

---

## **2. Promises in MongoDB**

A **promise** is an object representing the eventual completion (or failure) of an asynchronous operation. It provides `.then()` for success and `.catch()` for error handling.

### **Example: Using Promises in MongoDB**

```js
const { MongoClient } = require("mongodb");

const uri = "mongodb://localhost:27017";
const client = new MongoClient(uri);

client.connect()
  .then(() => {
    console.log("Connected to MongoDB");
    const db = client.db("mydatabase");
    const collection = db.collection("users");

    return collection.insertOne({ name: "Bob", age: 30 });
  })
  .then((result) => {
    console.log("Document inserted:", result.insertedId);
  })
  .catch((err) => {
    console.error("Error:", err);
  })
  .finally(() => {
    client.close();
  });
```

### **Key Points About Promises:**

âœ” **Avoids callback nesting (Cleaner code).**  
âœ” **`.then()` handles success, `.catch()` handles errors.**  
âœ” **`.finally()` ensures the connection is closed.**

---

## **3. Async/Await in MongoDB (Best Practice)**

Async/Await simplifies promises and makes code more readable.

### **Example: Using Async/Await in MongoDB**

```js
const { MongoClient } = require("mongodb");

const uri = "mongodb://localhost:27017";
const client = new MongoClient(uri);

async function insertData() {
  try {
    await client.connect();
    console.log("Connected to MongoDB");

    const db = client.db("mydatabase");
    const collection = db.collection("users");

    const result = await collection.insertOne({ name: "Charlie", age: 35 });
    console.log("Document inserted:", result.insertedId);
  } catch (err) {
    console.error("Error:", err);
  } finally {
    await client.close();
  }
}

insertData();
```

### **Key Points About Async/Await:**

âœ” **More readable than `.then()` chaining.**  
âœ” **Uses `try...catch` for error handling.**  
âœ” **Ensures proper flow of execution.**

---

## **4. Callback vs Promise vs Async/Await**

|Feature|Callbacks|Promises|Async/Await|
|---|---|---|---|
|Readability|âŒ Hard to read|âœ… Easier|âœ… Best|
|Nesting Issues|âŒ Callback Hell|âœ… No Nesting|âœ… No Nesting|
|Error Handling|âŒ Hard to manage|âœ… `.catch()`|âœ… `try...catch`|
|Execution Flow|âŒ Hard to trace|âœ… Structured|âœ… Sequential|

---

## **Conclusion**

âœ… **Callbacks** work but cause nesting issues.  
âœ… **Promises** improve readability and avoid callback hell.  
âœ… **Async/Await** is the best practice for MongoDB operations in Node.js.

Would you like to see an example with **pagination or authentication**? ğŸš€